const axios = require('axios');

const RISK_ENGINE_BASE_URL = process.env.RISK_ENGINE_URL || 'http://127.0.0.1:8000';
const RISK_ENGINE_TIMEOUT_MS = Number(process.env.RISK_ENGINE_TIMEOUT_MS || 5000);

const normalizeCategory = (type) => {
  const normalized = String(type || '').trim().toUpperCase();
  if (normalized === 'EXISTING') return 'existing';
  if (normalized === 'MIGRATING') return 'migrating';
  return 'new';
};

const normalizeVerificationStatus = (isVerified) => (isVerified ? 'verified' : 'pending');

const computeLocationRiskScore = (state) => {
  const highRiskStates = new Set(['JHARKHAND', 'BIHAR', 'UTTAR PRADESH']);
  const mediumRiskStates = new Set(['MAHARASHTRA', 'KARNATAKA', 'TAMIL NADU', 'TELANGANA']);
  const normalizedState = String(state || '').trim().toUpperCase();

  if (highRiskStates.has(normalizedState)) return 70;
  if (mediumRiskStates.has(normalizedState)) return 45;
  return 35;
};

const buildRiskPayload = (applicationData, user) => {
  const expectedMembersCount = Number(applicationData?.purposeInfo?.expectedMembersCount) || 0;
  const monthlyContribution = Number(applicationData?.purposeInfo?.targetMonthlyContribution) || 0;

  return {
    organiserCategory: normalizeCategory(applicationData.type),
    yearsOfOperation: Number(applicationData.years_of_operation) || 0,
    hasValidLicense: Boolean(applicationData.chit_license_number),
    groupSize: expectedMembersCount > 0 ? expectedMembersCount : Number(applicationData.total_active_members) || 0,
    monthlyContribution,
    locationRiskScore: computeLocationRiskScore(applicationData.state),
    pastDefaultRate: Number(applicationData.past_default_rate) || 0,
    complaintCount: Number(applicationData.complaint_count) || 0,
    verificationStatus: normalizeVerificationStatus(Boolean(user?.isKycVerified)),
  };
};

const conservativeFallbackRisk = () => ({
  riskScore: 75,
  riskLevel: 'HIGH',
  explanation: 'Fallback conservative score applied because AI risk engine was unavailable.',
  factors: ['Risk engine unavailable', 'Conservative fallback policy activated'],
  modelVersion: 'fallback_v1',
  fallback: true,
});

const calculateRiskViaEngine = async (payload) => {
  const response = await axios.post(`${RISK_ENGINE_BASE_URL}/calculate-risk`, payload, {
    timeout: RISK_ENGINE_TIMEOUT_MS,
    headers: { 'Content-Type': 'application/json' },
  });

  const riskScore = Number(response?.data?.riskScore);
  const riskLevel = String(response?.data?.riskLevel || '').toUpperCase();
  const explanation = String(response?.data?.explanation || '').trim();

  if (!Number.isFinite(riskScore) || riskScore < 0 || riskScore > 100) {
    throw new Error('Invalid riskScore from risk engine');
  }
  if (!['LOW', 'MEDIUM', 'HIGH'].includes(riskLevel)) {
    throw new Error('Invalid riskLevel from risk engine');
  }

  return {
    riskScore,
    riskLevel,
    explanation: explanation || 'Risk score generated by AI engine.',
    factors: Array.isArray(response?.data?.factors) ? response.data.factors : [],
    modelVersion: response?.data?.modelVersion || 'weighted_v1',
    fallback: false,
  };
};

const calculateOrganizerRisk = async (applicationData, user) => {
  const payload = buildRiskPayload(applicationData, user);

  try {
    const risk = await calculateRiskViaEngine(payload);
    return { payload, risk };
  } catch (error) {
    console.error('[RiskService] AI engine call failed, using fallback:', error.message);
    return { payload, risk: conservativeFallbackRisk() };
  }
};

module.exports = {
  calculateOrganizerRisk,
};
